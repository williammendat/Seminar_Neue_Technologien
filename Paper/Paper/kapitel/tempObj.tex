\section{Temporäre Objekte}\label{sec:tempobj}
Um temporäre Objekte verstehen zu können, sollte zuerst geklärt werden, was \emph{lvalues} und
\emph{rvalues} sind und worin diese zu Unterscheiden sind. Die Antwort darauf soll folgendes
Zitat liefern:
\begin{zitat}
    In concept (though not always in practice), rvalues correspond to temporary
    objects returned from functions, while lvalues correspond to objects you can refer to, either by
    name or by following a pointer or lvalue reference. A useful heuristic to determine whether an
    expression is an lvalue is to ask if you can take its address. If you can, it typically is. If
    you can’t, it’s usually an rvalue \cite{EffectiveC++}.
\end{zitat}
Wie zu sehen ist, resultieren \emph{rvalues} oft in temporären Objekten. Diese Objekte sind
insofern schlecht, da diese vom Compiler erzeugt werden, nur um Daten zu servieren, um dann sofort
wieder verworfen zu werden. Solch ein Verhalten frisst dann unnötigerweise Performance
\cite{HandsOn}[vgl].
\newline
\newline
Um ein solches Verhalten darzustellen, wird im Folgenden eine simple eigen Implementation der
\emph{String} klasse sowie die Klasse \emph{Person}, die eine \emph{const} Referenz übergeben im
Konstruktor übergeben bekommt, gezeigt:

\begin{lstlisting}[
    caption={Implementation einer String klasse},
    label=lst:String-klasse,
    frame=tlrb]
class String {
public:
	String(const char* string) {
		printf("Created\n");
		m_Size = strlen(string);
		m_Data = new char[m_Size + 1];
		memcpy(m_Data, string, m_Size);
		m_Data[m_Size] = 0;
	}

	[...]

protected:
    uint32_t m_Size;
    char* m_Data;
};

class Person{
public:
	//Konstructor akzeptiert auch rvalues
	Person(const String& name) : m_Name(name) { }
private:
	String m_Name;
}
\end{lstlisting}

Wenn nun eine Instanz von Person mit einem \emph{rvalue} erstellt wird, dann wird zuerst ein
Objekt vom Typ \emph{String} erzeugt, nur um dann die Daten an \emph{m\_Name} zu kopieren. Im
späteren Verlauf dieses Papers wird noch auf das Kopieren von Objekten eingegangen. Jedoch kann
für den Moment gesagt werden, dass das Verhalten, ein Objekt lediglich zu erzeugen, nur um die
Daten dann weiterzureichen, sehr zulasten der Performance gehen.